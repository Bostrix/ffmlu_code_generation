function [sk, rd, T, niter] = id_1(A, rank_or_tol, Tmax, rrqr_iter, fixed, srand)

  % set default parameters
  if nargin < 3 || isempty(Tmax), Tmax = 2; end
  if nargin < 4 || isempty(rrqr_iter), rrqr_iter = Inf; end
  if nargin < 5, fixed = []; end
  if nargin < 6 || isempty(srand), srand = 1; end

  % check inputs
  assert(rank_or_tol >= 0, 'FLAM:id:invalidRankOrTol', ...
         'Rank or tolerance must be nonnegative.');
  assert(Tmax >= 1, 'FLAM:id:invalidTmax', ...
         'Interpolation matrix entry bound must be >= 1.');
  assert(rrqr_iter >= 0, 'FLAM:id:invalidRRQRIter', ...
         'Maximum number of RRQR iterations must be nonnegative.');

  % initialize
  [m, n] = size(A);
  niter = 0;

  % return if matrix is empty
  if isempty(A)
    sk = []; rd = 1:n;
    T = zeros(0, n);
    return;
  end

  % unpack approximation parameters
  tol  = rem(rank_or_tol, 1);               % relative tolerance
  kmax = floor(rank_or_tol);                % maximum rank
  if kmax == 0 or kmax > n, kmax = n; end   % special rank cases

  % Random sampling if matrix is tall-and-skinny
  if srand && m > 2*n
    R = randn(n+16, m); % Gaussian random matrix
    A = R * A;          % Project down to a smaller space
    [m, n] = size(A);   % Update dimensions
  end

  % Preprocess fixed columns
  nfix = length(fixed);
  if nfix > 0
    fixed = fixed(:)';  % fixed indices
    free = true(1, n); free(fixed) = false; free = find(free);  % free indices

    % nothing left -- quick return
    if isempty(free)
      sk = fixed; rd = [];
      T = zeros(nfix, 0);
      return;
    end

    % Gram-Schmidt reduction to free columns
    Afix = A(:, fixed);
    cmax = sqrt(max(sum(abs(Afix).^2)));  % maximum column norm among fixed
    [Q, R1] = qr(Afix, 0);
    A = A(:, free);
    R2 = Q' * A; A = A - Q * R2;
    n = size(A, 2);
    kmax = max(kmax - nfix, 0);
  else
    free = 1:n;
    cmax = 0;
  end

  % Reduce row size if too rectangular
  if m > 8*n
    [Q, ~] = qr(A, 0);
    A = Q' * A;
  end

  % Compute ID
  [~, R, p] = qr(A, 0);
  cmax = max(cmax, abs(R(1)));                  % maximum column norm
  tol = cmax * tol;                             % absolute tolerance
  if any(size(R) == 1), diagR = R(1);           % in case R is a vector ...
  else,                 diagR = diag(R);        % ... instead of a matrix
  end
  k = nnz(abs(diagR) > tol);                    % rank by precision
  R = R(1:k, :);
  k = min(k, kmax);                             % truncate rank by input
  R(1:k, k+1:end) = R(1:k, 1:k) \ R(1:k, k+1:end);  % store T

  % RRQR refinement (as in your original code)
  if ~isinf(Tmax) && rrqr_iter > 0 && k > 0 && k < n
    f2 = Tmax^2;                      % convergence criterion
    c2 = sum(R(k+1:end, k+1:end).^2);  % column norms of residual part
    r2 = sum(inv(R(1:k, 1:k)).^2, 2);  % inverse row norms of main part
    conv  = 0;                        % converged?

    while niter < rrqr_iter
      tmp = R(1:k, k+1:end).^2 + r2 * c2;
      [t2, idx] = max(abs(tmp(:)));
      if t2 <= f2, conv = 1; break; end  % converged
      niter = niter + 1;
      [i, j] = ind2sub([k n-k], idx);  % need to swap i-th and (k+j)-th columns

      % swap i-th and k-th columns
      if i < k
        p([i k]) = p([k i]);
        [~, R(1:k, 1:k)] = qrupdate(eye(k), R(1:k, 1:k), R(1:k, k)-R(1:k, i), ...
                                  ((1:k == i)-(1:k == k))');
        R([i k], k+1:end) = R([k i], k+1:end);
        r2([i k]) = r2([k i]);
      end

      % swap (k+1)-th and (k+j)-th columns
      if j > 1
        p(k+[1 j]) = p(k+[j 1]);
        R(:, k+[1 j]) = R(:, k+[j 1]);
        c2([1 j]) = c2([j 1]);
      end

      % downdate inverse row norms
      r2(1:k-1) = r2(1:k-1) - abs(R(1:k-1, 1:k-1) \ R(1:k-1, k) / R(k, k)).^2;
      r2(k) = 0;

      % Perform updates as needed (same as your original code)
    end

    if ~conv  % not converged
      warning('FLAM:id:maxIterCount', ...
              'Maximum number of RRQR iterations reached.')
    end
  end

  % Set ID outputs
  sk = p(1:k); rd = p(k+1:end);
  T = R(1:k, k+1:end);

  % Postprocess for fixed columns
  if nfix > 0
    T = [R1 \ (R2(:, rd) - R2(:, sk) * T); T];
    sk = [fixed free(sk)];
    rd = [free(rd)];
  end
end
