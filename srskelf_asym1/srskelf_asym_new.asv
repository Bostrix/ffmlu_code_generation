function F = srskelf_asym_new(A_func_id, x, occ, rank_or_tol, pxyfun_func_id, opts)
    start = tic;

    % Ensure opts has the necessary fields
    requiredFields = {'nu', 'area', 'P', 'qcorr', 'contrast', 'wuse', 'symm', 'verb', 'lvlmax', 'ext', 'zk'};
    defaultValues = {0, 0, 0, 0, 0, 0, 'n', 0, Inf, [], 1.0};

    for k = 1:length(requiredFields)
        if ~isfield(opts, requiredFields{k})
            opts.(requiredFields{k}) = defaultValues{k};
        end
    end

    % Dispatch function handles based on identifiers
    switch A_func_id
        case 1
            A = @(i, j) Afun_lap_te(i, j, x, opts.nu, opts.area, opts.P, opts.qcorr, opts.contrast, opts.wuse);
        otherwise
            error('Invalid function identifier for A.');
    end

    switch pxyfun_func_id
        case 1
            pxyfun = @(x, slf, nbr, proxy, l, ctr) pxyfun_lap_neumann(x, slf, nbr, proxy, l, ctr, opts.area);
        otherwise
            error('Invalid function identifier for pxyfun.');
    end

    if opts.verb
        disp('This is standard asymmetric srskelf (RS-S).');
    end

    % Check inputs are sensible
    assert(strcmpi(opts.symm, 'p') || strcmpi(opts.symm, 'n'), ...
           'RSS:srskelf_asym:invalidSymm', ...
           'Symmetry parameter must be ''p'' or ''n''.');

    % Build tree to hold the discretization points
    N = size(x, 2);
    tic
    t = shypoct(x, occ, opts.lvlmax, opts.ext);

    if opts.verb
        fprintf(['-' * ones(1, 80) '\n'])
        fprintf('%3s | %6s | %8s | %8s | %8s | %8s | %10s (s)\n', ...
                'lvl', 'nblk', 'nRemIn', 'nRemOut', 'inRatio', 'outRatio', 'time')
        fprintf(['-' * ones(1, 80) '\n'])
        fprintf('%3s | %63.2e (s)\n', '-', toc)

        % Count the nonempty boxes at each level
        pblk = zeros(t.nlvl + 1, 1);
        for lvl = 1:t.nlvl
            pblk(lvl + 1) = pblk(lvl);
            for i = t.lvp(lvl) + 1:t.lvp(lvl + 1)
                if ~isempty(t.nodes(i).xi)
                    pblk(lvl + 1) = pblk(lvl + 1) + 1;
                end
            end
        end
    end

    % Initialize the data structure holding the factorization
    nbox = t.lvp(end);
    e = repmat(struct('sk', zeros(1, 0), 'rd', zeros(1, 0), 'nbr', zeros(1, 0), 'T', zeros(0, 0), 'E', zeros(0, 0), 'F', zeros(0, 0), 'L', zeros(0, 0), 'U', zeros(0, 0), 'C', zeros(0, 0), 'D', zeros(0, 0)), nbox, 1);
    F = struct('N', N, 'nlvl', t.nlvl, 'lvp', zeros(1, t.nlvl + 1), 'factors', e, 'symm', opts.symm);
    nlvl = 0;
    n = 0;
    rem = true(N, 1);
    lookup_list = zeros(nbox, 1);
    rng(1);

    for lvl = t.nlvl:-1:1
        time = tic;
        nlvl = nlvl + 1;
        nrem1 = sum(rem);

        for i = t.lvp(lvl) + 1:t.lvp(lvl + 1)
            if ~isempty(t.nodes(i).chld)
                xi_child = [t.nodes(t.nodes(i).chld).xi];
                t.nodes(i).xi = [t.nodes(i).xi, xi_child(:)'];
            end
        end

        boxsize = t.lrt / 2^(lvl - 1);
        tol = rank_or_tol;
        use_lproxy = true;

        if use_lproxy
            nterms = log(1.0 / tol) / log(1.0 / sqrt(3.0));
            nterms = max(nterms, 3);
        end
        p = (nterms + 1)^2;
        proxy = randn(3, p);
        proxy = 1.5 * bsxfun(@rdivide, proxy, sqrt(sum(proxy.^2)));

        for i = t.lvp(lvl) + 1:t.lvp(lvl + 1)
            slf = t.nodes(i).xi;
            nbr = [t.nodes(t.nodes(i).nbor).xi];

            nslf = length(slf);
            slf = sort(slf);
            nnbr = length(nbr);
            nbr = sort(nbr);

            if lvl == 2
                lst = [];
                l = t.lrt / 2^(lvl - 1);
            else
                lst = [t.nodes(t.nodes(i).ilist).xi];
                l = t.lrt / 2^(lvl - 1) * 3 / 2;
            end

            Kpxy = zeros(0, nslf);
            if lvl > 2
                [Kpxy, lst2] = pxyfun(x, slf, lst, proxy, l, t.nodes(i).ctr);
            end

            nlst = length(lst);
            lst = sort(lst);

            K1 = full(A(lst, slf));
            if strcmpi(opts.symm, 'n')
                K1 = [K1; conj(full(A(slf, lst)))'];
            end

            K2 = spget('lst', 'slf', t, F, lookup_list, i, opts.symm);
            if strcmpi(opts.symm, 'n')
                K2 = [K2; conj(spget('slf', 'lst', t, F, lookup_list, i, opts.symm))];
            end
            if lvl > 2
                K = [K1 + K2; Kpxy];
            else
                K = [K1 + K2; Kpxy];
            end

            [sk, rd, T] = id(K, rank_or_tol);

            if isempty(rd)
                continue
            end

            K = full(A(slf, slf)) + spget('slf', 'slf', t, F, lookup_list, i, opts.symm);
            K2 = full(A(nbr, slf)) + spget('nbr', 'slf', t, F, lookup_list, i, opts.symm);
            if strcmpi(opts.symm, 'n')
                K3 = full(A(slf, nbr)) + spget('slf', 'nbr', t, F, lookup_list, i, opts.symm);
            end

            K(rd, :) = K(rd, :) - conj(T)' * K(sk, :);
            K(:, rd) = K(:, rd) - K(:, sk) * T;
            K2(:, rd) = K2(:, rd) - K2(:, sk) * T;
            if strcmpi(opts.symm, 'n')
                K3(rd, :) = K3(rd, :) - conj(T)' * K3(sk, :);
            end

            if strcmpi(opts.symm, 'p')
                L = chol(K(rd, rd), 'lower');
                U = [];
                E = K(sk, rd) / conj(L)';
                G = [];
                C = K2(:, rd) / conj(L)';
                D = [];
            elseif strcmpi(opts.symm, 'n')
                [L, U] = lu(K(rd, rd));
                E = K(sk, rd) / U;
                G = L \ K(rd, sk);
                C = K2(:, rd) / U;
                D = L \ K3(rd, :);
            end

            n = n + 1;
            F.factors(n).sk = slf(sk);
            F.factors(n).rd = slf(rd);
            F.factors(n).nbr = nbr;
            F.factors(n).T = T;
            F.factors(n).E = E;
            F.factors(n).F = G;
            F.factors(n).L = L;
            F.factors(n).U = U;
            F.factors(n).C = C;
            F.factors(n).D = D;
            lookup_list(i) = n;

            t.nodes(i).xi = slf(sk);
            rem(slf(rd)) = 0;
        end
        F.lvp(nlvl + 1) = n;

        if opts.verb
            nrem2 = sum(rem);
            nblk = pblk(lvl) + t.lvp(lvl + 1) - t.lvp(lvl);
            fprintf('%3d | %6d | %8d | %8d | %8.2f | %8.2f | %10.2e (s)\n', ...
                    lvl, nblk, nrem1, nrem2, nrem1 / nblk, nrem2 / nblk, toc(time))
        end
    end

    F.factors = F.factors(1:n);
    if opts.verb
        fprintf(['-' * ones(1, 80) '\n'])
        toc(start)
    end
end

function A = spget(Ityp, Jtyp, t, F, lookup_list, node_idx, symm)
    if strcmpi(Ityp, 'slf')
        I_ = t.nodes(node_idx).xi;
        m_ = length(I_);
    elseif strcmpi(Ityp, 'nbr')
        I_ = [t.nodes(t.nodes(node_idx).nbor).xi];
        m_ = length(I_);
    elseif strcmpi(Ityp, 'lst')
        I_ = [t.nodes(t.nodes(node_idx).ilist).xi];
        m_ = length(I_);
    end

    if strcmpi(Jtyp, 'slf')
        J_ = t.nodes(node_idx).xi;
        n_ = length(J_);
    elseif strcmpi(Jtyp, 'nbr')
        J_ = [t.nodes(t.nodes(node_idx).nbor).xi];
        n_ = length(J_);
    elseif strcmpi(Jtyp, 'lst')
        J_ = [t.nodes(t.nodes(node_idx).ilist).xi];
        n_ = length(J_);
    end

    A = zeros(m_, n_); % Initialize A with correct type
    update_list = false(length(t.nodes), 1);
    get_update_list_iterative(t, update_list, node_idx);
    update_list_indices = find(update_list);
    lookup_indices = lookup_list(update_list_indices);
    lookup_indices = lookup_indices(lookup_indices ~= 0)';
    for idx = 1:length(lookup_indices)
        jj = lookup_indices(idx);
        g = F.factors(jj);
        xj = [g.sk, g.nbr];
        f = length(g.sk);

        if strcmpi(Ityp, Jtyp)
            idxI = find_locations_t(xj, I_);
            tmp1 = idxI ~= 0;
            subI = idxI(tmp1);
            idxI1 = tmp1(1:f);
            idxI2 = tmp1(f + 1:end);
            tmp1 = [g.E(idxI1, :); g.C(idxI2, :)];
            if strcmpi(symm, 'p')
                A(subI, subI) = A(subI, subI) - tmp1 * tmp1';
            elseif strcmpi(symm, 'n')
                tmp2 = [g.F(:, idxI1), g.D(:, idxI2)];
                A(subI, subI) = A(subI, subI) - tmp1 * tmp2;
            end
        else
            idxI = find_locations_t(xj, I_);
            idxJ = find_locations_t(xj, J_);

            tmp1 = idxI ~= 0;
            tmp2 = idxJ ~= 0;

            subI = idxI(tmp1);
            subJ = idxJ(tmp2);
            idxI1 = tmp1(1:f);
            idxI2 = tmp1(f + 1:end);
            idxJ1 = tmp2(1:f);
            idxJ2 = tmp2(f + 1:end);

            tmp1 = [g.E(idxI1, :); g.C(idxI2, :)];
            if strcmpi(symm, 'p')
                tmp2 = [g.E(idxJ1, :); g.C(idxJ2, :)]';
            elseif strcmpi(symm, 'n')
                tmp2 = [g.F(:, idxJ1), g.D(:, idxJ2)];
            end
            A(subI, subJ) = A(subI, subJ) - tmp1 * tmp2;
        end
    end
end

function get_update_list_iterative(t, update_list, node_idx)
    stack = zeros(length(t.nodes), 1); % Initialize stack with the correct type
    stack_ptr = 1;
    stack(stack_ptr) = node_idx;
    while stack_ptr > 0
        current_node = stack(stack_ptr);
        stack_ptr = stack_ptr - 1;
        update_list(current_node) = true;

        % Extract snbor field
        snbor_list = t.nodes(current_node).snbor;
        for k = 1:length(snbor_list)
            update_list(snbor_list(k)) = true;
        end

        % Update children
        chld = t.nodes(current_node).chld;
        for k = 1:length(chld)
            stack_ptr = stack_ptr + 1;
            stack(stack_ptr) = chld(k);
        end
    end
end

function locs = find_locations_t(big_sorted_list, elements_to_find)
    locs = zeros(size(big_sorted_list)); % Ensure locs has the same type as big_sorted_list
    for i = 1:length(elements_to_find)
        element = elements_to_find(i);
        loc = binary_search_t(big_sorted_list, element);
        if loc ~= -1
            locs(loc) = i;
        end
    end

    function loc = binary_search_t(arr_, target_)
        left = 1;
        right = length(arr_);
        while left <= right
            mid = floor((left + right) / 2);
            if arr_(mid) == target_
                loc = mid;
                return;
            elseif arr_(mid) < target_
                left = mid + 1;
            else
                right = mid - 1;
            end
        end
        loc = -1;
    end
end
